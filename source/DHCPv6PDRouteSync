#!/usr/bin/env python

# Copyright (c) 2021, Arista Networks, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#  - Redistributions of source code must retain the above copyright notice,
# this list of conditions and the following disclaimer.
#  - Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#  - Neither the name of Arista Networks nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARISTA NETWORKS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# dhcpv6-pd-route-sync
#
#    Written by:
#       Rob Martin, Arista Networks
#

"""
This EOS SDK script will mount the state of the Route Table
"""

import eossdk
import syslog
import sys
from jsonrpclib import Server

# Set to allow unverified cert for eAPI call
import ssl
try:
    _create_unverified_https_context = ssl._create_unverified_context
except AttributeError:
    # Legacy Python that doesn't verify HTTPS certificates by default
    pass
else:
    # Handle target environment that doesn't support HTTPS verification
    ssl._create_default_https_context = _create_unverified_https_context

__author__ = 'robmartin, dcapetz'
__version__ = '0.1.0'

# Global variables - Credentials for remote switch
remote_password = "0227DcDc!"

class DHCPV6PDROUTESYNC(eossdk.AgentHandler, eossdk.FibHandler):
    def __init__(self, fibMgr, agentMgr):
        eossdk.AgentHandler.__init__(self,agentMgr)
        eossdk.FibHandler.__init__(self,fibMgr)
        self.tracer = eossdk.Tracer("DHCPv6PDRouteSync")
        self.fibMgr_ = fibMgr
        self.agentMgr_ = agentMgr
        self.tracer.trace0("Constructed")

    def on_initialized(self):
        self.tracer.trace0("We are initialized!")
        self._to_syslog("Agent STARTED", 'DHCPv6 PD Route Sync Agent Initialized')
        # Loop through any pre existing configurations to load
        for _option in self.agentMgr_.agent_option_iter():
            self.on_agent_option(_option, self.agentMgr_.agent_option(_option))

    def on_agent_option(self,optionName, value):
        """
        Function called when Daemon Option config added.
        """
        self._to_syslog("Option ADDED", "Key: {key}, Value: {value}".format(
            key = optionName,
            value = value
        ))
        #if optionName.lower() == "pdmask":
        #    if int(value) not in range(48, 65):
        #        self._to_syslog("Valid Prefix Delegation Mask Length is from /48 to /64")
        #        self.agentMgr_.status_set(optionName, "INVALID")
        #    else:
        #        self.agentMgr_.status_set(optionName, value)
        #elif optionName.lower() == 'vrf':
        #    if value not in "TEST123":
        #        self._to_syslog("Invalid VRF Selection")
        #        self.agentMgr_.status_set(optionName, "INVALID")
        #    else:
        #        self.agentMgr_.status_set(optionName, value)
        self.agentMgr_.status_set(optionName, value)
        if optionName == "pdmask":
            for _route in self.fibMgr_.fib_route_iter():
                if _route.route_type() == eossdk.ROUTE_TYPE_UNKNOWN:
                    if "/{value}".format(value = value) in _route.route_key().prefix().to_string():
                        try:
                            _route_via = self.get_route_via(_route)
                            #self._to_syslog("DEBUG","GOT VIA")
                            _str_prefix = _route.route_key().prefix().to_string()
                            _str_next_hop = _route_via["nexthop"]
                            _str_next_hop_intf = _route_via["intf"]
                            #self._to_syslog("DEBUG",_str_prefix)
                            #self._to_syslog("DEBUG",_str_next_hop_intf)
                            #self._to_syslog("DEBUG",_str_next_hop)
                            self.add_peer_route(_str_prefix, _str_next_hop_intf, _str_next_hop)
                        except:
                            self._to_syslog("DEBUG","ERROR")
#        else:
#        # Catch All for any destinations/hosts
#            new_host = True
#            # Called if VRF option is to be removed
#            if not value:
#                self._to_syslog("Option REMOVED", "Removing VRF {vrf}".format(
#                    vrf = value
#                ))
#                self.agentMgr_.status_del(optionName)
#            #Addition/Update of host
#            else:
#                _node_ip = self.verify_ip_addr(value)
#                if optionName in ALL_HOSTS:
#                    if ALL_HOSTS[optionName].ip != '':
#                        new_host = False
#                # Check if IP Address if valid
#                if _node_ip:
#                    if new_host:
#                            self._to_syslog("HOST ADDED", "{node} node added for updates".format(
#                                node = optionName
#                            ))
#                            new_host.set_msg("Initializing Host Route")
#                            ALL_HOSTS[optionName] = new_host
#                            self.agentMgr_.status_set(optionName, new_host.status_msg)
#                    else:
#                        if optionName in ALL_HOSTS:
#                            ALL_HOSTS[optionName].full_ip = _node_ip
#                    route_prefix = self.find_route_prefix(_node_ip)
#                    if route_prefix:
#                        _route_via = self.get_route_via(route_prefix)
#                        _str_next_hop = _route_via.hop().to_string()
#                        _str_route_prefix = route_prefix.route_key().prefix().to_string()
#                        self._to_syslog("INFO", "Found {route} route via destination {via}".format(
#                            route = _str_route_prefix,
#                            via = _str_next_hop
#                        ))
#                        ALL_HOSTS[optionName].set_prefix(_str_route_prefix)
#                        ALL_HOSTS[optionName].set_next_hop(_str_next_hop)
#                        ALL_HOSTS[optionName].set_msg("{network} network via {hop} next-hop".format(
#                            network = _str_route_prefix,
#                            hop = _str_next_hop
#                        ))
#                        self.agentMgr_.status_set(optionName, new_host.status_msg)
#                        #self.add_kernel_route(str(_node_ip), _str_next_hop)
#                else:
#                    self._to_syslog("HOST ERROR", "{node} node does not have a valid IPv4 Address, Provided: {ip}".format(
#                        node = optionName,
#                        ip = value
#                    ))
        # ADD LOGIC FOR NEW PEER ROUTER OPTION
    
    def get_route_via(self, _ip_route):
        """
        Function to get the next hop for a specified route.
        Parameters:
        _ip_route = EosSdk ip_route type
        """
        _fec_id = _ip_route.fec_id()
        _tmp_fec = self.fibMgr_.fib_fec(eossdk.FibFecKey(_fec_id))
        _route_via = _tmp_fec.via()
        route_data = {
            "intf" : _route_via[0].intf().to_string(),
            "nexthop" : _route_via[0].hop().to_string()
        }
        return(route_data)
        

    def on_route_set(self, _fib_route_update):
        mask = "/{mask}".format(mask = self.agentMgr_.agent_option("pdmask"))
        if _fib_route_update.route_type() == eossdk.ROUTE_TYPE_UNKNOWN:
            if mask in _fib_route_update.route_key().prefix().to_string():
                self._to_syslog("DHCPv6 PD DETECTED","New prefix {prefix} has been delegated".format(
                    prefix = _fib_route_update.route_key().prefix().to_string()
                ))
                try:
                    _route_via = self.get_route_via(_fib_route_update)
                    _str_prefix = _fib_route_update.route_key().prefix().to_string()
                    _str_next_hop = _route_via["nexthop"]
                    _str_next_hop_intf = _route_via["intf"]
                    self.add_peer_route(_str_prefix, _str_next_hop_intf, _str_next_hop)
                except:
                    self._to_syslog("DEBUG","ERROR")

    def on_route_del(self, _fib_route_update_key):
        mask = "/{mask}".format(mask = self.agentMgr_.agent_option("pdmask"))
        if mask in _fib_route_update_key.prefix().to_string():
            _str_prefix = _fib_route_update_key.prefix().to_string()
            self._to_syslog("DHCPv6 PD EXPIRED","Potential Delegated prefix {prefix} removed from local FIB. Checking peer...".format(
                prefix = _str_prefix
            ))
            self.remove_peer_route(_str_prefix)

    def add_peer_route(self, _prefix, _intf, _via):
        """
        Fuction to add static IPv6 route to peer router
        Parameters:
        _prefix = Subnet of Delegated Prefix (string)
        _intf = Nexthop Interface (string)
        _via = Nexthop IPv6 Address (string)
        """
        route_cmd = "ipv6 route {prefix} {intf} {via}".format(
            prefix = _prefix,
            intf = _intf,
            via = _via
        )
        peer = self.agentMgr_.agent_option("peer")
        self.PASSWORD = remote_password
        peer_url = "https://admin:{password}@{peer}/command-api".format(
            password = self.PASSWORD,
            peer = peer
        )
        try:
            peer_switch = Server(peer_url)
            config_resp = peer_switch.runCmds(1, [
                "enable",
                "configure",
                route_cmd,
                "end"
            ])
            self._to_syslog("DHCPv6 PD Route ADDED","Configured route for delegated prefix {prefix} to {via} on peer router {peer}".format(
                prefix = _prefix,
                via = _via,
                peer = peer
            ))
        except:
            self._to_syslog("DEBUG","ERROR CONFIGURING PEER")

    def remove_peer_route(self, _prefix):
        """
        Fuction to remove static IPv6 route to peer router
        Requires check of current static routes to ensure accuracy
        Parameters:
        _prefix = Subnet of Delegated Prefix (string)
        """
        route_show_cmd = "show ipv6 route {prefix} static".format(
            prefix = _prefix
        )
        peer = self.agentMgr_.agent_option("peer")
        self.PASSWORD = remote_password
        peer_url = "https://admin:{password}@{peer}/command-api".format(
            password = self.PASSWORD,
            peer = peer
        )
        try:
            peer_switch = Server(peer_url)
            show_resp = peer_switch.runCmds(1, [route_show_cmd])
            if show_resp[0]["routes"]:
                self._to_syslog("Peer Route Found","Matching static route for {prefix} found on peer {peer}".format(
                    prefix = _prefix,
                    peer = peer
                ))
                _via = show_resp[0]["routes"][_prefix]["vias"][0]["nexthopAddr"]
                _intf = show_resp[0]["routes"][_prefix]["vias"][0]["interface"]
                route_cmd = "no ipv6 route {prefix} {intf} {via}".format(
                    prefix = _prefix,
                    intf = _intf,
                    via = _via
                )
                try:
                    config_resp = peer_switch.runCmds(1,[
                        "enable",
                        "configure",
                        route_cmd,
                        "end"
                    ])
                    self._to_syslog("DHCPv6 PD Route REMOVED","Deleted route for delegated prefix {prefix} to {via} on peer router {peer}".format(
                        prefix = _prefix,
                        via = _via,
                        peer = peer
                    ))
                except:
                    self._to_syslog("DEBUG","ERROR REMOVING ROUTE FROM PEER")
            else:
                self._to_syslog("PD ROUTE not found","Matching static route for {prefix} not found on peer {peer}. No action taken.".format(
                    prefix = _prefix,
                    peer = peer
                ))
        except:
            self._to_syslog("DEBUG","ERROR CHECKING ROUTE ON PEER")

    def _to_syslog(self, sys_type, sys_msg):
        syslog.syslog("%%SDK-DHCPv6PDRouteSync-Log-6-LOG: {type}: {msg}".format(
            type = sys_type,
            msg = sys_msg
        ))
    
        

if __name__ == '__main__':
    syslog.openlog('SDK-DHCPv6PDRouteSync-Log',0,syslog.LOG_LOCAL4)
    sdk = eossdk.Sdk()
    _ = DHCPV6PDROUTESYNC(sdk.get_fib_mgr(eossdk.MODE_TYPE_READ_NOTIFYING),sdk.get_agent_mgr())
    sdk.main_loop(sys.argv)